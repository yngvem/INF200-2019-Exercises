

Classes and methods
-------------------

The text below provides a brief description of the classes you are to
create and the methods these classes shall implement. You are allowed to
add additional methods. The description of classes is mostly in text
form, ``test_base_pa02.py`` specifies the detailed call signatures. You
shall write docstrings for classes and methods yourself.

``Board`` class
---------------

The ``Board`` class shall manage all information about ladders, snakes,
and the goal.

1. If no parameters are given to the ``Board`` constructor, it shall
   create a standard board, with the snakes, ladders, and goal as in
   PA01.
2. Method ``goal_reached()`` shall return true if it is passed a
   position at or beyond the goal.
3. Method ``position_adjustment()`` shall handle changes in position due
   to snakes and ladders. It accepts a position as argument and returns
   the number of positions the player must move forward (in case of a
   ladder) or backward (chute), to get to the correct position. If the
   player is not at the start of a chute or ladder, the method returns
   0.

``Player`` class
----------------

The ``Player`` class and its subclasses manage information about player
position, including information on which board a player “lives”. 1. The
player constructor must receive the board as argument:

.. code:: python

           board = Board()
           player = Player(board)

1. The ``move()`` method moves the player by implementing a die cast,
   the following move and, if necessary, a move up a ladder or down a
   chute. It does not return anything.

``ResilientPlayer`` class
~~~~~~~~~~~~~~~~~~~~~~~~~

This is a subclass of ``Player`` with slightly different moving
behavior: When a resilient player slips down a chute, he will take extra
steps in the next move, in addition to the roll of the die. The number
of extra steps is provided as an argument to the constructor, default is
1. Extra steps are taken immediately after the steps prescribed by the
die and before snakes and ladders are checked.

``LazyPlayer`` class
~~~~~~~~~~~~~~~~~~~~

This is a subclass of ``Player`` as well. After climbing a ladder, a
lazy player drops a given number of steps. The number of dropped steps
is an optional argument to the constructor, default is 1. The player
never moves backward: if, e.g., the die cast results in 1 step and the
player is to drop 3 steps, the player does not move -2 steps but just
stays in place.

``Simulation`` class
--------------------

The ``Simulation`` class manages an entire simulation.

In addition to the board, the ``Simulation`` constructor receives - a
random seed to seed the random number generator; - a boolean flag
indicating whether the order or players should be randomized before the
start of each game played; - a list of player *classes*: for each game,
a list of player objects will be created, one player for each entry in
the list.

The example below shows a constructor call for simulations on the
default board in which two players, three resilient players and one lazy
player compete with each other, using a different starting order in each
game:

.. code:: python

   sim = Simulation([Player, Player, ResilientPlayer, ResilientPlayer,
                     ResilientPlayer, LazyPlayer],
                     randomize_players=True)


The class has the following methods:

1. ``single_game()`` runs a single game returning a tuple consisting of
   the number of moves made and the type of the winner, e.g.
   ``(25, 'LazyPlayer')``.
2. ``run_simulation()`` runs a given number of games and stores the
   results in the ``Simulation`` object. It returns nothing.
3. ``get_results()`` returns all results generated by
   ``run_simulation()`` calls so far as a list of result tuples, e.g.,
   ``[(10, 'Player'), (6, 'ResilientPlayer')]``.
4. ``winners_per_type()`` returns a dictionary mapping player types to
   the number of wins, e.g.,
   ``{'Player': 4, 'LazyPlayer': 2, 'ResilientPlayer': 5}``
5. ``durations_per_type()`` returns a dictionary mapping player types to
   lists of game durations for that type, e.g.,
   ``{'Player': [11, 25, 13], 'LazyPlayer': [39], 'ResilientPlayer': [8, 7, 6, 11]}``
6. ``players_per_type`` returns a dictionary showing how many players of
   each type participate, e.g.,
   ``{'Player': 3, 'LazyPlayer': 1, 'ResilientPlayer': 0}``

Retrieving class names
~~~~~~~~~~~~~~~~~~~~~~

For a class ``C``, ``C.__name__`` will return the class name as string
``'C'``. If ``c`` is an instance of class ``C``, then ``type(c)`` will
return the class and ``type(c).__name__`` will provide the class name as
string ``'C'``.
